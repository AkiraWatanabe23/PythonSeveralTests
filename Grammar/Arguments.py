
####################
#引数(Argumant)の参照渡し、値渡しについて
#https://www.javadrive.jp/python/userfunc/index3.html

#値渡し...関数を呼び出す時に、仮引数に指定した値を「コピーして実引数に渡す」方法
#　　　   関数内で変数の値を変更しても、呼び出し元が参照している変数の値は変更されない
#参照渡し...関数を呼び出す時に、仮引数に指定した値が「保管されている場所の情報を実引数に渡す」方法
#　　　　   関数内で変数の値を変更した場合、呼び出し元が参照している変数の値も変更される
"""
pythonでは、引数を指定して関数を呼び出す時は、「参照渡し」が使用される

※str, int 等の一度作成すると変更できないオブジェクトを
引数に指定した場合と、
List, Dic 等の作成後に変更できるオブジェクトを
引数に指定した場合とで挙動が異なる
"""

#変更できないオブジェクトを引数に指定した場合
def func_one(n):
    print(id(n)) #nに代入されたオブジェクトのIDを出力

def pass_by_value_like(n):
    print(n)
    n += 5 # <- 値の変更
    print(n)

a = 10
print(id(a)) # -> 140722845111368
func_one(a)  # -> 140722845111368
#↑同じオブジェクトを参照している

print(a)    # -> 10
pass_by_value_like(a) # -> 10
#             -> 15
print(a)    # -> 10 ... 呼び出し元の変数の値に変更がない
#これは、関数で値を更新した時に新しいオブジェクトを参照するようになったため
#上記のように、参照渡しでも値渡しのような挙動になる


#変更できるオブジェクトを引数に指定した場合
def func_two(n):
    print(id(n))

def pass_by_refarence(n):
    print(n)
    n[0] += 5
    print(n)

a = [10, 20]
print(id(a)) # -> 2787859597696
func_two(a)  # -> 2787859597696
#↑同じオブジェクトを参照している

print(a)             # -> [10, 20]
pass_by_refarence(a) # -> [10, 20]
#                      -> [15, 20]
print(a)             # -> [15, 20] ... 呼び出し元の変数の値が変更されている
#上記のように、参照渡しの挙動をする
#もしList等の変更可能なオブジェクトを値渡しで参照したい場合、「copy(), deepcopy() 関数」を利用する
####################

####################
#位置引数、キーワード引数とは
#https://www.javadrive.jp/python/userfunc/index6.html

#関数を呼び出すときにその関数に引数がある場合、「位置引数」「キーワード引数」という記述方法がある
def positional_arg(arg1, arg2):
    print(f"引数1 : {arg1}, 引数2 : {arg2}")

def keyword_arg(arg1, arg2):
    print(f"引数1 : {arg1}, 引数2 : {arg2}")

#位置引数を用いた方法
positional_arg(10, 'aaa')         # -> 引数1 : 10, 引数2 : aaa
#キーワード引数を用いた方法
keyword_arg(arg1='test', arg2=39) # -> 引数1 : test, 引数2 : 39

"""
位置引数
→ 呼び出し側で指定した引数の値が順番に関数側で引数のところに定義した変数に順番に代入する形式

キーワード引数
→ 関数を呼び出す側でどの仮引数にどの値を渡すのかを 「仮引数の名前=値」 の形で指定する形式
  (どの仮引数に値を入れるかを直接指定するため、引数を記述する順番は自由)

  ex.) keyword_arg(arg2=39, arg1='test') のように記述してもよい
"""
####################

####################
#可変長引数「*args」「**kwrags」
#https://note.nkmk.me/python-args-kwargs-usage/

"""
*args ... 「*」をつけた引数を定義することで、任意の数の引数を指定できる
             位置引数やキーワード引数と組み合わせることもできる
            (複数の値を引数として渡した場合、それらはタプルとして受け取られる)
            (位置引数のみが渡された場合、空のタプルになる)

**kwargs ... 「**」をつけた引数を定義することで、任意の数の[キーワード引数]を指定できる
                (関数内では、引数名->key, 値->value の辞書として受け取られる)
                ※「**」をつけた引数は、引数の最後でのみ定義できる

両方とも、宣言しておいて使わないこともできる
"""

def tuple_arg(*args):
    print(type(args)) # -> <class 'tuple'>
    print(*args)      # -> 1 3 5 7 9
    print(sum(args))  # -> 25

tuple_arg(1, 3, 5, 7, 9)
#↑ 複数の引数を渡すことが出来る

def dic_arg(**kwrags):
    print(kwrags)

dic = {'key1' : 1, 'key2' : 2, 'key3' : 3}

dic_arg(test=1) # -> {'test': 1}
dic_arg(**dic)  # -> {'key1': 1, 'key2': 2, 'key3': 3}
#辞書に「**」をつけて引数に指定することもできる
####################

####################
#オブジェクトが「変更可能」「変更不可能」とはどういうことか
#https://pouhon.net/python-immutable/1831/
#ex.)  変更不可能(イミュータブル)なオブジェクト...文字列、数値、tuple
#      変更可能(ミュータブル)なオブジェクト...list, dict

#1, 変更不可能(イミュータブル)なオブジェクト
tup = (1, 2, 3, 4, 5)
print(id(tup))
print(id((1, 2, 3, 4, 5)))
#↑同じID(識別値)...tupと(1, 2, 3, 4, 5)は、同じ値が代入されている
tup += (6, 7, 8)
print(id(tup))
#↑tupを参照しているのに、さっきとIDが変わっている

"""
変数と値の関係性について
変数名がついた箱に値そのものが入っている ... x
変数と値がそれぞれ別々の領域に確保されている ... ○

実際は、「変数」と「値」が紐でつながっているイメージ(値を参照している状態)
print(id(tup))
print(id((1, 2, 3, 4, 5)))
↑この2行をみた時、上記の2つは同じ値を指し示しているので、同じIDが出力されることになる
tup += (6, 7, 8)
↑ここでは、元々の「tup = (1, 2, 3, 4, 5)」に「(6, 7, 8)」を加えているのではなく
「(1, 2, 3, 4, 5) + (6, 7, 8)」という「新たな値」が生成され、変数tupの参照先(紐のつながる先)を
切り替えている
これにより、l.138 print(id(tup)) では元のIDとは別のものになっている
(l.135 print(id((1, 2, 3, 4, 5))) は、新しく値を生成しているのではなく「既にある値」を読み込んでいる)
"""
#まとめ
#変更不可能とは、何が「不可能」なのか?
# →「不可能」とは、値そのものを書き換えることが不可能であるということ
#  実際に変更されているのは、変数の「参照先」であって「値そのもの」ではない

#2, 変更可能(ミュータブル)なオブジェクト
li = [1, 2, 3]
print(id(li))
li += [4, 5, 6]
print(id(li))
#↑Listの値が変更されているが、新しく値を生成している訳ではないため同じIDが返ってくる

new_li = [1, 2, 3]
tup2 = (new_li, 4, 5)
print(tup2) # -> ([1, 2, 3], 4, 5)
print(id(tup2))
#上記のタプルには、変更可能なオブジェクト(List)が入っている
new_li[0] = 10
print(tup2) # -> ([10, 2, 3], 4, 5)
#↑Listは変更可能なオブジェクトなので、要素の値を変更することができる
print(id(tup2))

"""
この時、Listの中身が「直接書き換えられた」状態であり、
Listもタプルも参照先を切り替えてはいないので
l.173 と l.178 の print(id(tup2)) は同じIDを出力する
"""
#まとめ
#変更可能とは、何が「可能」なのか?
# →「可能」とは、変更不可能なオブジェクトとは逆に、
#    値そのものを書き換えることが可能であるということ
####################